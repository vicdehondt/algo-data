#lang r6rs

;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
;-*-*                                                                 *-*-
;-*-*                         p-Polyphase Sort                        *-*-
;-*-*                                                                 *-*-
;-*-*                        Wolfgang De Meuter                       *-*-
;-*-*                   2010  Software Languages Lab                  *-*-
;-*-*                    Vrije Universiteit Brussel                   *-*-
;-*-*                                                                 *-*-
;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

(library
 (n-polyphase-sort)
 (export sort!)
 (import (rnrs base)
         (rnrs control)
         (srfi :9)
         (rename (a-d sorting internal comparative quicksort-m3-bounded) (sort quicksort))
         (prefix (a-d heap standard) heap:)
         (prefix (a-d disk file-system) fs:)
         (prefix (a-d disk disk) disk:)
         (prefix (a-d file sequential input-file) in:)
         (prefix (a-d file sequential output-file) out:)
   ;      (prefix (a-d sorting external file-with-varying-runs) fwrs:)
         (prefix (a-d sorting external outputfile-with-varying-runs) ofvr:)
         (prefix (a-d sorting external inputfile-with-varying-runs) ifvr:)
         (a-d scheme-tools)) ; import random-integer
 
 (define rlen 10)
 (define irun (make-vector rlen))
 
 (define (read-run! file)
   (let loop
     ((indx 0))
     (cond ((or (= indx rlen) (not (in:has-more? file)))
            indx)
           (else
            (vector-set! irun indx (in:read file))
            (loop (+ indx 1))))))
 
 (define (write-run! ofvr imax)
   (let loop
     ((indx 0))
     (ofvr:write! ofvr (vector-ref irun indx))
     (if (< (+ indx 1) imax)
         (loop (+ indx 1)))))
  
 (define-record-type bundle
   (make-bundle s d r f)
   bundle?
   (s selecteds)
   (d dummies)
   (r runs)
   (f files))
 
 (define (output fils)
   (vector-ref (files fils) (order fils)))
 (define (input fils i)
   (vector-ref (files fils) i))
 
 (define (dummy fils indx)
   (vector-ref (dummies fils) indx))
 (define (dummy! fils indx cnt)
   (vector-set! (dummies fils) indx cnt))
 (define (run fils indx)
   (vector-ref (runs fils) indx))
 (define (run! fils indx cnt)
   (vector-set! (runs fils) indx cnt))
 (define (file fils indx)
   (vector-ref (files fils) indx))
 (define (file! fils indx file)
   (vector-set! (files fils) indx file))
 (define (selected fils indx)
   (vector-ref (selecteds fils) indx))
 (define (selected! fils indx sltd)
   (vector-set! (selecteds fils) indx sltd))
 
 (define (order fils)
   (- (vector-length (files fils)) 1))
 
 (define (make-aux-bundle disks)
   (define p (- (vector-length disks) 1))
   (define rslt (make-bundle (make-vector (+ p 1))
                             (make-vector (+ p 1))
                             (make-vector (+ p 1))
                             (make-vector (+ p 1))))
   (define name "aux-")
   (do ((indx 0 (+ indx 1)))
     ((= indx p))
     (file! rslt indx  (ofvr:new (vector-ref disks indx) 
                                 (string-append name (number->string indx))
                                 +inf.0))
     (run! rslt indx 1)
     (dummy! rslt indx 1)
     (selected! rslt indx #f))
   (file! rslt p (ofvr:new (vector-ref disks p)
                           (string-append name (number->string p))
                           +inf.0))
   (run! rslt p 0)
   (dummy! rslt p 0)
   rslt)
 
 (define (delete-aux-bundle! fils)
   (define p (order fils))
   (do ((idx 0 (+ idx 1)))
     ((= idx p)
      (ofvr:delete! (file fils p)))
     (ifvr:delete! (file fils idx))))

 (define (distribute! inpt fils <<?)
   (define p (order fils))
   (let loop
     ((indx 0)
      (nmbr (read-run! inpt)))
     (when (> nmbr 0)
       (quicksort irun nmbr <<?)
       (write-run! (input fils indx) nmbr)
       (ofvr:new-run! (file fils indx))
       (dummy! fils indx (- (dummy fils indx) 1))
       (cond ((< (dummy fils indx) (dummy fils (+ indx 1)))
              (loop (+ indx 1) (read-run! inpt)))
             ((= (dummy fils indx) 0)
              (let ((rmax (run fils 0)))
                (do ((i 0 (+ i 1)))
                  ((= i p))
                  (dummy! fils i (+ rmax (run fils (+ i 1)) (- (run fils i))))
                  (run!   fils i (+ rmax (run fils (+ i 1)))))
                (loop 0 (read-run! inpt))))
             (else
              (loop 0 (read-run! inpt))))))
   (do ((indx 0 (+ indx 1)))
     ((= indx p))
     (ofvr:reread! (input fils indx)))
   (eat-dummies fils))
  
 (define (eat-dummies fils)
   (define p (order fils))
   (define skip
     (let ((dmin +inf.0))
       (do ((indx 0 (+ indx 1)))
         ((= indx p)
          dmin)
         (if (< (dummy fils indx) dmin)
             (set! dmin (dummy fils indx))))))
   (dummy! fils p (+ (dummy fils p) skip))
   (do ((indx 0 (+ indx 1)))
     ((= indx p))
     (dummy! fils indx (- (dummy fils indx) skip))
     (run! fils indx (- (run fils indx) skip)))
   (run! fils p (+ (run fils p) skip)))
 
 (define (start-new-runs! fils)
   (define p (order fils))
   (do ((indx 0 (+ indx 1)))
     ((= indx p)
      (run! fils p (+ (run fils p) 1)))
     (run! fils indx (- (run fils indx) 1)))
   (do ((indx 0 (+ indx 1)))
     ((= indx p))
     (cond ((and (ifvr:has-more? (file fils indx))
                 (= (dummy fils indx) 0))
            (if (selected fils indx)
                (ifvr:new-run! (file fils indx)))
            (selected! fils indx #t))
           (else
            (selected! fils indx #f)
            (if (> (dummy fils indx) 0)
                (dummy! fils indx (- (dummy fils indx) 1)))))))
 
 (define (next-phase!? fils)
   (define p (order fils))
   (define last-fil (file fils p))
   (define last-run (run fils p))
   (define last-dum (dummy fils p))
   (do ((indx p (- indx 1)))
     ((= indx 0))
     (file! fils indx (file fils (- indx 1)))
     (dummy! fils indx (dummy fils (- indx 1)))
     (run! fils indx (run fils (- indx 1)))
     (selected! fils indx (selected fils (- indx 1))))
   (file! fils  0 last-fil)
   (dummy! fils 0 last-dum)
   (run! fils   0 last-run)
   (selected! fils 0 #f)
   (ofvr:reread! (input fils 0))
   (ifvr:rewrite! (output fils))
   (eat-dummies fils)
   (> (run fils (- p 1)) 0))
  
 (define (read-from-files? heap fils)
   (define p (order fils))
   (cond ((> (run fils (- p 1)) 0)
          (start-new-runs! fils)
          (do ((indx 0 (+ indx 1)))
            ((= indx p) #t)
            (if (selected fils indx)
                (heap:insert! heap (cons indx (ifvr:read (file fils indx)))))))
         (else #f)))

 (define (serve heap files)
   (define el (heap:delete! heap))
   (define indx (car el))
   (define rcrd (cdr el))
   (if (ifvr:run-has-more? (input files indx)); try where we read
       (heap:insert! heap (cons indx (ifvr:read (input files indx)))))
   rcrd)
 
 (define (merge! fils <<?)
   (define heap (heap:new (order fils)
                          (lambda (c1 c2) 
                            (<<? (cdr c1) (cdr c2)))))
   (let merge-files 
     ()
     (cond ((read-from-files? heap fils)
            (let merge-p-runs
              ((rcrd (serve heap fils)))
              (ofvr:write! (output fils) rcrd)
              (if (not (heap:empty? heap))
                  (merge-p-runs (serve heap fils))))
            (ofvr:new-run! (output fils))
            (merge-files))
           ((next-phase!? fils)
            (merge-files)))))

 (define (collect! files inpt)
   (define last (input files 0))
    (in:rewrite! inpt)
    (let loop
     ((rcrd (ifvr:read last)))
     (out:write! inpt rcrd)
     (if (ifvr:run-has-more? last)
         (loop (ifvr:read last))))
    (out:close-write! inpt))
  
 (define (sort! file dsks <<?)
   (define fils (make-aux-bundle dsks))
   (distribute! file fils <<?)
   (merge! fils <<?)
   (collect! fils file)
   (delete-aux-bundle! fils)))