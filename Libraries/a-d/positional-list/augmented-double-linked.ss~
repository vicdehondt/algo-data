#lang r6rs

;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
;-*-*                                                                 *-*-
;-*-*           Double Linked Positional Lists (Augmented)            *-*-
;-*-*                                                                 *-*-
;-*-*                       Wolfgang De Meuter                        *-*-
;-*-*                 2010 Programming Technology Lab                 *-*-
;-*-*                   Vrije Universiteit Brussel                    *-*-
;-*-*                                                                 *-*-
;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-
;-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-

(library 
 (augmented-double-linked-positionalal-list)
 (export new positional-list-tag equality
         attach-first! attach-last! attach-middle!
         detach-first! detach-last! detach-middle!
         length empty? full? update! peek
         first last has-next? has-previous? next previous)
 (import (except (rnrs base) length)
         (rnrs mutable-pairs))
 
 (define (make-list-node val prev next)
   (cons prev (cons val next)))
 (define (list-node-val node)
   (cadr node))
 (define (list-node-val! node val)
   (set-car! (cdr node) val))
 (define (list-node-next node)
   (cddr node))
 (define (list-node-next! node next)
   (set-cdr! (cdr node) next))
 (define (list-node-prev node)
   (car node))
 (define (list-node-prev! node prev)
   (set-car! node prev))
 
 (define positional-list-tag 'double-linked-augmented-list)
 (define (make head tail size ==?)
   (list positional-list-tag head tail size ==?))
 (define (head plst)
   (cadr plst))
 (define (head! plst node)
   (set-car! (cdr plst) node))
 (define (tail plst)
   (caddr plst))
 (define (tail! plst node)
   (set-car! (cddr plst) node))
 (define (size plst)
   (cadddr plst))
 (define (size! plst s)
   (set-car! (cdddr plst) s))
 (define (equality plst)
   (caddr (cddr plst)))
 (define (new ==?)
   (make '() '() 0 ==?))
  
 (define (attach-first! plst val)
   (define first (head plst))
   (define node (make-list-node val '() first))
   (head! plst node)
   (if (not (null? first))
       (list-node-prev! first node)
       (tail! plst node)) ; first null => last null
   (size! plst (+ 1 (size plst))))
 
 (define (attach-middle! plst val pos)
   (define next (list-node-next pos))
   (define node (make-list-node val pos next))
   (list-node-next! pos node)
   (if (not (null? next))
     (list-node-prev! next node)
     (tail! plst node)); next null => new last
   (size! plst (+ 1 (size plst))))
 
 (define (attach-last! plst val)
   (define last (tail plst))
   (define node (make-list-node val last '()))
   (define first (head plst))
   (if (null? first) ; first is last
     (head! plst node)
     (list-node-next! last node))
   (tail! plst node)
   (size! plst (+ 1 (size plst))))
 
 (define (detach-first! plst)
   (define first (head plst))
   (define second (list-node-next first))
   (head! plst second)
   (if (not (null? second))                     ; first is the only one
     (list-node-prev! second '())
     (tail! plst '()))
   (size! plst (- (size plst) 1)))
 
 (define (detach-middle! plst pos)
   (define next (list-node-next pos))
   (define prev (list-node-prev pos))
   (list-node-next! prev next)
   (list-node-prev! next prev)
   (size! plst (- (size plst) 1)))
 
 (define (detach-last! plst pos)
   (define first (head plst))
   (define second (list-node-next first))
   (define last (tail plst))
   (define penultimate (list-node-prev last))
   (if (null? second) ; last is also first
     (head! plst '())
     (list-node-next! penultimate '()))
   (tail! plst penultimate)
   (size! plst (- (size plst) 1)))
 
 (define (length plst)
   (size plst))
 
 (define (full? plst)
   #f)
 
 (define (empty? plst)
   (null? (head plst)))
 
 (define (first plst)
   (if (null? (head plst))
     (error "list empty (first)" plst)
     (head plst)))
 
 (define (last plst)
   (if (null? (tail plst))
     (error "list empty (last)" plst)
     (tail plst)))
 
 (define (has-next? plst pos)
   (not (null? (list-node-next pos))))
 
 (define (has-previous? plst pos)
   (not (eq? pos (head plst))))
 
 (define (next plst pos)
   (if (not (has-next? plst pos))
     (error "list has no next (next)" plst)
     (list-node-next pos)))
 
 (define (previous plst pos)
   (if (not (has-previous? plst pos))
     (error "list has no previous (previous)" plst)
     (list-node-prev pos)))
 
 (define (update! plst pos val)
   (list-node-val! pos val)
   plst)
 
 (define (peek plst pos)
   (list-node-val pos)))